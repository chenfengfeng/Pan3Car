# SQLite 数据库文件说明

**更新日期：** 2025-01-14

---

## 📁 WAL 模式下的三个文件

SQLite 在启用 WAL (Write-Ahead Logging) 模式后，会产生三个文件：

### 1. `pan3_data.db` (主数据库文件)
- **作用**：存储所有表结构和数据
- **大小**：~52KB（当前）
- **必需**：✅ 是

### 2. `pan3_data.db-wal` (预写日志文件)
- **作用**：记录所有写操作，用于提升性能和并发支持
- **大小**：0-32KB（动态变化）
- **必需**：✅ 是

### 3. `pan3_data.db-shm` (共享内存文件)
- **作用**：WAL 文件的索引，支持多连接并发访问
- **大小**：32KB
- **必需**：✅ 是

---

## ❌ 为什么不能只保留 `.db` 文件？

**原因：**

WAL 模式的工作机制：

```
写操作流程：
┌─────────────────────────┐
│ 应用发起写入请求        │
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ 1. 写入到 .wal 文件    │ ← 快速写操作
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ 2. 通过 .shm 索引管理  │ ← 多连接协调
└───────────┬─────────────┘
            ↓
┌─────────────────────────┐
│ 3. 后台定期同步到.db   │ ← 持久化存储
└─────────────────────────┘
```

**如果删除 WAL 文件：**
- ❌ 未提交的写操作会丢失
- ❌ 可能导致数据不一致
- ❌ 数据库损坏风险

**如果删除 SHM 文件：**
- ❌ 并发访问冲突
- ❌ 锁机制失效
- ❌ 数据库无法正常打开

---

## ⚙️ 为什么使用 WAL 模式？

**代码配置：**

```javascript
// core/database/db.js
dbInstance.pragma('journal_mode = WAL');
```

**优势：**
- ✅ **高性能**：写操作直接写入 WAL，比传统模式快 2-4 倍
- ✅ **并发支持**：支持多个连接同时读写
- ✅ **数据安全**：崩溃恢复能力强
- ✅ **不需要**：提供最佳的读写平衡

**性能对比：**

| 模式 | 写入速度 | 并发支持 | 使用场景 |
|------|---------|---------|---------|
| DELETE (传统) | 慢 | 否 | 单线程应用 |
| WAL (当前) | 快 | 是 | ✅ 多线程/并发 |

---

## 🔍 文件管理

### 正常情况

**运行时：**
```
三个文件都存在
pan3_data.db (52KB)
pan3_data.db-wal (动态变化)
pan3_data.db-shm (32KB)
```

**数据库关闭后：**
- SQLite 自动清理 `.wal` 和 `.shm`
- 保留主文件 `.db`

### 异常情况

**如果数据库崩溃：**
```
三个文件都保留
→ 下次启动时 SQLite 自动检查和修复
```

**手动删除：**

```bash
# ❌ 危险操作！
rm pan3_data.db-wal  # 可能导致数据丢失
rm pan3_data.db-shm  # 会导致打开失败

# ✅ 正确做法
# 关闭所有数据库连接后再删除
# 或者重启服务器让 SQLite 自动处理
```

---

## 📊 WAL 模式工作原理

### 读取操作

```
应用请求读取
    ↓
SQLite 检查 WAL
    ↓
找到最新数据 → 返回
```

### 写入操作

```
应用请求写入
    ↓
快速写入 WAL (0.1ms)
    ↓
后台异步同步到 .db (不影响性能)
```

### Checkpoint（检查点）

```
WAL 大小超过阈值
    ↓
自动 checkpoint
    ↓
将 WAL 数据合并到 .db
    ↓
清空 WAL 文件
```

---

## 🛡️ 数据安全

### 三种情况的数据恢复

**情况 1：正常关闭**
```
所有数据已同步到 .db
WAL 和 SHM 自动删除
下次启动：干净启动
```

**情况 2：崩溃但有 WAL**
```
下次启动：
1. 读取 .db（基线数据）
2. 读取 .wal（最新更改）
3. 合并恢复完整数据
4. 返回正常状态
```

**情况 3：崩溃且 WAL 被删**
```
下次启动：
- 只能读取 .db 的旧数据
- WAL 中的最新更改丢失 ❌
```

---

## 💡 建议

### ✅ 正确做法

1. **不要手动删除**这些文件
2. **一起备份**三个文件（如果想备份）
3. **让 SQLite 自动管理**
4. **正常关闭数据库**（需要时调用 `closeDatabase()`）

### ❌ 错误做法

1. 只保留 `.db` 文件
2. 手动删除 `.wal` 或 `.shm`
3. 在运行中操作这些文件
4. 在没有关闭连接时删除文件

---

## 🎯 总结

**三个文件都是必需的：**

```
WAL 模式 = 三个文件协同工作
├── .db   → 持久存储（主数据库）
├── .wal  → 快速写操作（预写日志）
└── .shm  → 并发控制（共享内存）
```

**类比：**
- `.db` = 银行金库（永久保存）
- `.wal` = 交易流水（快速记录）
- `.shm` = 协调员（并发管理）

**性能优势：**
- 没有 WAL：每次写操作都要修改主数据库（慢）
- 有 WAL：写操作立即完成，后台批量同步（快）

---

**结论：必须保留所有三个文件，这是 WAL 模式的基本要求！**

如果想禁用 WAL 模式（不推荐），需要修改代码：

```javascript
// core/database/db.js
// ❌ 注释掉这行
// dbInstance.pragma('journal_mode = WAL');
```

但这样会牺牲性能和并发能力。

